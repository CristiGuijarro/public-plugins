<html>
<head>
<title>Compara API Tutorial</title>
</head>

<body>

<h1>Compara API Tutorial</h1>


<h2 id="intro">Introduction</h2>

<p>
This tutorial is an introduction to the <a href="index.html">EnsEMBL Compara API</a>.
Knowledge of the
<a href="/info/docs/api/core/index.html">EnsEMBL Core API</a> and of the concepts and conventions in the
<a href="/info/docs/api/core/core_tutorial.html">EnsEMBL Core API tutorial</a> is assumed.
Documentation about the Compara database schema is available in
<a href="https://github.com/Ensembl/ensembl-compara/tree/release/[[SPECIESDEFS::ENSEMBL_VERSION]]/docs" rel="external">ensembl-compara/docs/</a>
from the EnsEMBL GitHub repository, and while is not necessary for this tutorial,
an understanding of the database tables may help as many of the adaptor modules are table-specific.
</p>

<p>
The latest API course at the moment is related to the version 84 of the API (released in March 2016), but all examples below should still work.
The materials can be found <a href="https://github.com/Ensembl/ensembl-presentation/tree/master/API/Compara">here</a>. The correct version of the codebase for these exercises can be found on <a href="https://github.com/Ensembl/ensembl-compara/tree/release/84">GitHub</a>.
</p>

<p>
You can also visit our filmed API course on the EBI's <a href="http://www.ebi.ac.uk/training/online/course/ensembl-filmed-api-workshop">Training online Platform</a>.
The API was in version 71 at that time.
</p>

<h2 id="install">Installing the API</h2>

<p>
<a href="/info/docs/api/api_installation.html">API installation</a> and updating is the same as per the core API.
</p>

<h2 id="connection">Connecting to an EnsEMBL Compara database</h2>
<p>
The public MySQL server lives at <code>host=ensembldb.ensembl.org</code> and will be used throughout this tutorial.
<br><br>
There are two API ways to connect to the EnsEMBL Compara database:
<ul>
<li>In most cases you will prefer the implicit way - using <code>Bio::EnsEMBL::Registry</code> module,
which can read either a global or a specific configuration file or auto-configure itself.</li>
<li>However there are cases where you might want more flexibility provided by the
explicit creation of a <code>Bio::EnsEMBL::Compara::DBSQL::DBAdaptor</code>.</li>
</ul>
</p>

<h3>Implicitly, using Bio::EnsEMBL::Registry auto-configuration (recommended)</h3>

<p>
To use the auto-configuration feature, you will first need to supply the connection parameters to the
Registry loader. For instance, if you want to connect to the the public EnsEMBL databases you can
use the following command in your scripts:
</p>

<pre class="code sh_perl">
use Bio::EnsEMBL::Registry;
Bio::EnsEMBL::Registry-&gt;load_registry_from_db(
    -host =&gt; 'ensembldb.ensembl.org',
    -user =&gt; 'anonymous'
);
</pre>

<p>
This will initialize the Registry, from which you will be able to create object-specific adaptors later.

Alternatively, you can use a shorter version based on a URL (this is usually for more advanced cases):</p>

<pre class="code sh_perl">
use Bio::EnsEMBL::Registry;
Bio::EnsEMBL::Registry-&gt;load_registry_from_url('mysql://anonymous@ensembldb.ensembl.org/');
</pre>

<h3>Implicitly, using the Bio::EnsEMBL::Registry configuration file</h3>

<p>
You will need to have a registry configuration file set up.
By default, it takes the file defined by the <code>ENSEMBL_REGISTRY</code> environment variable or
the file named <code>.ensembl_init</code> in your home directory if the former is not found.
Additionally, you can use a specific file
(see perldoc <code>Bio::EnsEMBL::Registry</code> or later in this document for some examples on how to use a different file).
Please, refer to the <a href="/info/docs/api/registry.html">EnsEMBL registry documentation</a> for details about this option.
</p>

<h3>Explicitly, using the Bio::EnsEMBL::Compara::DBSQL::DBAdaptor</h3>

<p>
EnsEMBL Compara data, like core data, is stored in a MySQL relational database.
If you want to access a Compara database, you will need to connect to it.
This is done in exactly the same way as to connect to an EnsEMBL core database,
but using a Compara-specific DBAdaptor. One parameter you have to supply
in addition to the ones needed by the Registry is the <code>-dbname</code>, which by convention contains the release number:
</p>

<pre class="code sh_perl">
use Bio::EnsEMBL::Compara::DBSQL::DBAdaptor;

my $host   = 'ensembldb.ensembl.org';
my $user   = 'anonymous';
my $dbname = 'ensembl_compara_84';

my $comparadb= new Bio::EnsEMBL::Compara::DBSQL::DBAdaptor(
    -host   =&gt; $host,
    -user   =&gt; $user,
    -dbname =&gt; $dbname,
    -species=&gt; 'Multi',
);
</pre>

<p>
'Multi' is the default name used for automatically-loaded Compara databases and is used throughout this
tutorial. If you use another value here, use it in all the <code>get_adaptor</code> function calls (see
below).
</p>

<p>
Building your own DBAdaptor is useful if you need to access several databases from the same script, as
you can give a different <em>species</em> parameter to each database.
</p>

<h2>EnsEMBL Compara objects and adaptors</h2>
<h3>Objects</h3>
<p>
    There are several compara-specific objects that form the basis for many operations within the API. These objects will be found in most scripts, regardless of which type of data you're interested in. An in-depth look at more data-specific objects will be covered as the tutorial progresses.

    <h4>GenomeDB</h4>
    <p>A single GenomeDB object represents a specific assembly for a specific species.</p>

    <h4>SpeciesSet</h4>
    <p>SpeciesSet objects represent a collection of GenomeDB objects. They are used to define which set of species an analysis should be run on.</p>

    <h4>Method</h4>
    <p>A Method object represents a type of analysis. Below is a non-exhaustive list of methods available:</p>
    <table width="800">
        <tr><th align="left">Method name</th><th align="left">Description</th></tr>
        <tr><td><code>LASTZ_NET</code></td><td>Pairwise whole genome alignment using LastZ</td></tr>
        <tr><td><code>EPO</code></td><td>Multiple whole genome alignment (WGA), with ancestral inference, using Enredo, Pecan and Ortheus</td></tr>
        <tr><td><code>EPO_LOW_COVERAGE</code></td><td>Multiple WGA for lower coverage genomes, using EPO and LASTZ</td></tr>
        <tr><td><code>PECAN</code></td><td>Multiple WGA using Mercator and Pecan</td></tr>
        <tr><td><code>CACTUS_HAL</code></td><td>Multiple WGA using progressiveCactus (* additional setup required - see <a href="https://github.com/Ensembl/ensembl-compara/blob/release/[[SPECIESDEFS::ENSEMBL_VERSION]]/README.md#api-to-access-hal-alignments-progressive-cactus">here</a> for details)</td></tr>
        <tr><td><code>ENSEMBL_ORTHOLOGUES</code></td><td>Ortholog calls between a pair of species</td></tr>
        <tr><td><code>ENSEMBL_PARALOGUES</code></td><td>Paralog calls for a species</td></tr>
        <tr><td><code>FAMILY</code></td><td>Protein families for a set of species</td></tr>
        <tr><td><code>PROTEIN_TREES</code></td><td>Gene trees for protein coding genes</td></tr>
        <tr><td><code>NC_TREES</code></td><td>Gene trees for non-coding RNAs</td></tr>
    </table>
    <br>
    
    <h4>MethodLinkSpeciesSet</h4>
    <p>
        MethodLinkSpeciesSet objects link a SpeciesSet to a Method. For example, a MethodLinkSpeciesSet object linking a (human, mouse) SpeciesSet and a LASTZ_NET method represents our pairwise whole genome alignment between human and mouse.
        <br>
        All compara data will be linked to a MethodLinkSpeciesSet (MLSS), so finding the relevant MLSS object is often the first step to data retrieval.
    </p>

    <h4>DnaFrag</h4>
    <p>
        DnaFrags represent chromosomes and scaffolds, similar to SeqRegion objects in the core API.
    </p>

</p>

<h3 id="adaptors">Adaptors</h2>

<p>
EnsEMBL Compara adaptors are used to fetch data from the database. Data are returned as EnsEMBL objects.
For instance, the GenomeDBAdaptor returns <code>Bio::EnsEMBL::Compara::GenomeDB</code> objects.
</p>

<p>
Below is a non-exhaustive list of EnsEMBL Compara adaptors that are most often used:
</p>

<table width="600">
    <tr><th align="left">Adaptor name</th><th align="left">Object fetched</th></tr>
    <tr><td><code>GenomeDBAdaptor</code></td><td><code>Bio::EnsEMBL::Compara::GenomeDB</code></td></tr>
    <tr><td><code>DnaFragAdaptor</code></td><td><code>Bio::EnsEMBL::Compara::DnaFrag</code></td></tr>
    <tr><td><code>GenomicAlignBlockAdaptor</code></td><td><code>Bio::EnsEMBL::Compara::GenomicAlignBlock</code></td></tr>
    <tr><td><code>SyntenyRegionAdaptor</code></td><td><code>Bio::EnsEMBL::Compara::SyntenyRegion</code></td></tr>
    <tr><td><code>GeneMemberAdaptor</code></td><td><code>Bio::EnsEMBL::Compara::GeneMember</code></td></tr>
    <tr><td><code>GeneTreeAdaptor</code></td><td><code>Bio::EnsEMBL::Compara::GeneTree</code></td></tr>
    <tr><td><code>HomologyAdaptor</code></td><td><code>Bio::EnsEMBL::Compara::Homology</code></td></tr>
    <tr><td><code>FamilyAdaptor</code></td><td><code>Bio::EnsEMBL::Compara::Family</code></td></tr>
</table>
<br>
<p>
Only some of these adaptors will be used for illustration as part of this tutorial through commented perl scripts code.
</p>

<p>
You can get the adaptors from the Registry with the <code>get_adaptor</code> command. You need to specify three arguments: the
species name, the type of database and the type of object. Therefore, in order to get the GenomeDBAdaptor for the
Compara database, you will need the following command:
</p>

<pre class="code sh_perl">
my $genome_db_adaptor = Bio::EnsEMBL::Registry-&gt;get_adaptor(
    'Multi', 'compara', 'GenomeDB');
</pre>

<p>
<strong>NB:</strong> As the EnsEMBL Compara DB is a multi-species database, the standard species name is 'Multi'. The type of the
database is 'compara'. For custom DBAdaptors, replace 'Multi' with the value of the <code>-species</code> parameter you have defined.
</p>

<h2 id="code_intro">Code Conventions</h2>

<p>
Refer to the <a href="/info/docs/api/core/index.html">EnsEMBL core tutorial</a> for a good description of the coding conventions normally used in EnsEMBL.
</p>

<p>
We can divide the fetching methods of the ObjectAdaptors into two categories: the <code>fetch_by</code> and <code>fetch_all_by</code>. The former return one single object while the latter return a reference to an array of objects.
</p>

<pre class="code sh_perl">
my $this_genome_db = $genome_db_adaptor-&gt;fetch_by_name_assembly("Homo sapiens"); # If the assembly name is missing, will select the current one
</pre>

<pre class="code sh_perl">
my $all_genome_dbs = $genome_db_adaptor-&gt;fetch_all();
foreach my $this_genome_db (@{$all_genome_dbs}) {
  print $this_genome_db-&gt;name, "\n";
}
</pre>

<h3>Compara Template Script</h3>
<p>Given the above information and conventions, we know that the majority of compara scripts will resemble the following template:</p>
<pre class="code sh_perl">
use strict;
use Bio::EnsEMBL::Registry;
my $reg = "Bio::EnsEMBL::Registry";

# Auto-configure the registry
$reg-&gt;load_registry_from_db(
    -host =&gt; "ensembldb.ensembl.org",
    -user =&gt; "anonymous"
);

# Get the adaptor object for the data type you want
# e.g. GeneTree
my $xx_adaptor = $reg-&gt;get_adaptor("Multi", "compara", "XX");

# Fetch the data objects using the adaptor
# e.g. get all the genes in a given gene tree
my $all_interesting_xx = $xx_adaptor-&gt;fetch_all_by_YY();

print "All XX objects from E!Compara :\n";
foreach my $this_xx (@$all_interesting_xx) {
    # Do some stuff with the data object
    print "\t", $this_xx-&gt;stable_id, "\n";
}
</pre>

<h2 id="genomic_align">Whole Genome Alignments</h2>

<p>
The Compara database contains a number of different types of whole genome alignments.
A listing about what are these different types can be found in the ensembl-compara/docs/schema_doc.html document in method_link section.
</p>

<h3>GenomicAlignBlock objects</h3>

<p>
GenomicAlignBlocks are the preferred way to store and fetch genomic alignments.
A GenomicAlignBlock contains several GenomicAlign objects.
Every GenomicAlign object corresponds to a piece of genomic sequence aligned with the other GenomicAlign in the same GenomicAlignBlock.
A GenomicAlign object is always in relation with other GenomicAlign objects
and this relation is defined through the GenomicAlignBlock object.
Therefore the usual way to fetch genomic alignments is by fetching GenomicAlignBlock objects.
We have to start by getting the corresponding adaptor:
</p>

<pre class="code sh_perl">
# Getting the GenomicAlignBlock adaptor:
my $genomic_align_block_adaptor = Bio::EnsEMBL::Registry-&gt;get_adaptor(
    'Multi', 'compara', 'GenomicAlignBlock');
</pre>

<p>
In order to fetch the right alignments we need to specify a couple of data:
the type of alignment and the piece of genomic sequence in which we are looking for alignments.
The type of alignment is a more tricky now:
you need to specify both the alignment method and the set of genomes.
In order to simply this task, you could use the new <code>Bio::EnsEMBL::Compara::MethodLinkSpeciesSet</code> object.
The best way to use them is by fetching them from the database:
</p>

<pre class="code sh_perl">
# Getting the GenomeDB adaptor:
my $genome_db_adaptor = Bio::EnsEMBL::Registry-&gt;get_adaptor(
    'Multi', 'compara', 'GenomeDB');

# Fetching GenomeDB objects for human and mouse:
my $human_genome_db = $genome_db_adaptor-&gt;fetch_by_name_assembly('homo_sapiens');
my $mouse_genome_db = $genome_db_adaptor-&gt;fetch_by_name_assembly('mus_musculus');

# Getting the MethodLinkSpeciesSet adaptor:
my $method_link_species_set_adaptor = Bio::EnsEMBL::Registry-&gt;get_adaptor(
    'Multi', 'compara', 'MethodLinkSpeciesSet');

# Fetching the MethodLinkSpeciesSet object corresponding to LASTZ_NET alignments between human and mouse genomic sequences:
my $human_mouse_lastz_net_mlss =
    $method_link_species_set_adaptor-&gt;fetch_by_method_link_type_GenomeDBs(
        "LASTZ_NET",
        [$human_genome_db, $mouse_genome_db]
    );
</pre>

<p>
There are two ways to fetch GenomicAlignBlocks.
One uses <code>Bio::EnsEMBL::Slice</code> objects while the second one is based on
<code>Bio::EnsEMBL::Compara::DnaFrag</code> objects for specifying the piece of genomic
sequence in which we are looking for alignments.
</p>

<pre class="code sh_perl">
my $query_species = 'human';
my $seq_region = '14';
my $seq_region_start = 75000000;
my $seq_region_end   = 75010000;

# Getting the Slice adaptor:
my $slice_adaptor = Bio::EnsEMBL::Registry-&gt;get_adaptor(
    $query_species, 'core', 'Slice');

# Fetching a Slice object:
my $query_slice = $slice_adaptor-&gt;fetch_by_region(
    'toplevel',
    $seq_region,
    $seq_region_start,
    $seq_region_end);

# Fetching all the GenomicAlignBlock corresponding to this Slice from the pairwise alignments (LASTZ_NET)
# between human and mouse:
my $genomic_align_blocks =
    $genomic_align_block_adaptor-&gt;fetch_all_by_MethodLinkSpeciesSet_Slice(
      $human_mouse_lastz_net_mlss,
      $query_slice);

# We will then (usually) need to restrict the blocks to the required positions in the reference sequence
# ($seq_region_start and $seq_region_end)

foreach my $genomic_align_block( @{ $genomic_align_blocks }) {
    my $restricted_gab = $genomic_align_block-&gt;restrict_between_reference_positions($seq_region_start, $seq_region_end);
}
</pre>

<p>
Here is an example script with all of this:
</p>

<pre class="code sh_perl">
use strict;
use Bio::EnsEMBL::Registry;
use Bio::EnsEMBL::Utils::Exception qw(throw);
use Bio::AlignIO;
use Getopt::Long;

my $usage = qq{
perl DumpMultiAlign.pl
  Getting help:
    [--help]

  For the query slice:
    [--species species]
        Query species. Default is "human"
    [--coord_system coordinates_name]
        Query coordinate system. Default is "chromosome"
    --seq_region region_name
        Query region name, i.e. the chromosome name
    --seq_region_start start
    --seq_region_end end

  For the alignments:
    [--alignment_type method_link_name]
        The type of alignment. Default is "LASTZ_NET"
    [--set_of_species species1:species2:species3:...]
        The list of species used to get those alignments. Default is
        "human:mouse". The names should correspond to the name of the
        core database in the registry_configuration_file or any of its
        aliases

  Ouput:
    [--output_format clustalw|fasta|...]
        The type of output you want. "clustalw" is the default.
    [--output_file filename]
        The name of the output file. By default the output is the
        standard output
};

my $species = "human";
my $coord_system = "chromosome";
my $seq_region = "14";
my $seq_region_start = 75000000;
my $seq_region_end = 75010000;
my $alignment_type = "LASTZ_NET";
my $set_of_species = "human:mouse";
my $output_file = undef;
my $output_format = "clustalw";
my $help;

GetOptions(
    "help" =&gt; \$help,
    "species=s" =&gt; \$species,
    "coord_system=s" =&gt; \$coord_system,
    "seq_region=s" =&gt; \$seq_region,
    "seq_region_start=i" =&gt; \$seq_region_start,
    "seq_region_end=i" =&gt; \$seq_region_end,
    "alignment_type=s" =&gt; \$alignment_type,
    "set_of_species=s" =&gt; \$set_of_species,
    "output_format=s" =&gt; \$output_format,
    "output_file=s" =&gt; \$output_file);

# Print Help and exit
if ($help) {
    print $usage;
    exit(0);
}

if ($output_file) {
    open(STDOUT, "&gt;$output_file") or die("Cannot open $output_file");
}

Bio::EnsEMBL::Registry-&gt;load_registry_from_db(
    -host =&gt; 'ensembldb.ensembl.org', -user =&gt; 'anonymous');

# Getting all the Bio::EnsEMBL::Compara::GenomeDB objects
my $genome_dbs;
my $genome_db_adaptor = Bio::EnsEMBL::Registry-&gt;get_adaptor(
    'Multi', 'compara', 'GenomeDB');

throw("Cannot connect to Compara") if (!$genome_db_adaptor);

foreach my $this_species (split(":", $set_of_species)) {
    my $this_meta_container_adaptor = Bio::EnsEMBL::Registry-&gt;get_adaptor(
        $this_species, 'core', 'MetaContainer');

    throw("Registry configuration file has no data for connecting to &lt;$this_species&gt;")
        if (!$this_meta_container_adaptor);

    my $this_production_name = $this_meta_container_adaptor-&gt;get_production_name;

    # Fetch Bio::EnsEMBL::Compara::GenomeDB object
    my $genome_db = $genome_db_adaptor-&gt;fetch_by_name_assembly($this_production_name);

    # Add Bio::EnsEMBL::Compara::GenomeDB object to the list
    push(@$genome_dbs, $genome_db);
}

# Getting Bio::EnsEMBL::Compara::MethodLinkSpeciesSet object
my $method_link_species_set_adaptor = Bio::EnsEMBL::Registry-&gt;get_adaptor(
    'Multi', 'compara', 'MethodLinkSpeciesSet');

my $method_link_species_set =
    $method_link_species_set_adaptor-&gt;fetch_by_method_link_type_GenomeDBs(
      $alignment_type,
      $genome_dbs);

throw("The database do not contain any $alignment_type data for $set_of_species!")
    if (!$method_link_species_set);

# Fetching the query Slice:
my $slice_adaptor = Bio::EnsEMBL::Registry-&gt;get_adaptor($species, 'core', 'Slice');

throw("Registry configuration file has no data for connecting to &lt;$species&gt;")
    if (!$slice_adaptor);

my $query_slice = $slice_adaptor-&gt;fetch_by_region('toplevel', $seq_region, $seq_region_start, $seq_region_end);

throw("No Slice can be created with coordinates $seq_region:$seq_region_start-".
    "$seq_region_end") if (!$query_slice);

# Fetching all the GenomicAlignBlock corresponding to this Slice:
my $genomic_align_block_adaptor = Bio::EnsEMBL::Registry-&gt;get_adaptor(
    'Multi', 'compara', 'GenomicAlignBlock');

my $genomic_align_blocks =
    $genomic_align_block_adaptor-&gt;fetch_all_by_MethodLinkSpeciesSet_Slice(
      $method_link_species_set,
      $query_slice);

my $all_aligns;

# Get a Bio::SimpleAlign object from every GenomicAlignBlock
foreach my $this_genomic_align_block (@$genomic_align_blocks) {
    my $simple_align = $this_genomic_align_block-&gt;get_SimpleAlign;
    push(@$all_aligns, $simple_align);
}

# print all the genomic alignments using a Bio::AlignIO object
my $alignIO = Bio::AlignIO-&gt;newFh(
    -interleaved =&gt; 0,
    -fh =&gt; \*STDOUT,
    -format =&gt; $output_format,
    -idlength =&gt; 10
);

foreach my $this_align (@$all_aligns) {
    print $alignIO $this_align;
}

exit;
</pre>

<h2 id="gene_resources">Gene trees, Homologies and Protein clusters</h2>

<p>
All the gene trees, homologies and families refer to GeneMembers and SeqMembers. Homology objects store orthologous and paralogous relationships between members, GeneTree objects represent the evolutionary history of a set of members, and Family objects are clusters of members.
</p>


<h3>*Member objects</h3>

<p>
A member represent either a gene (GeneMember) or a sequence-bearing locus, e.g. a protein or a transcript (SeqMember). Most of them
are defined in the corresponding EnsEMBL core database. For
instance, the sequence for the human gene ENSG00000004059
is stored in the human core database.
</p>

<p>
The fetch_by_stable_id method of the corresponding *MemberAdaptor returns Members by their stable_id.
Here is a simple example:
</p>

<pre class="code sh_perl">
# get the MemberAdaptor
my $genemember_adaptor = Bio::EnsEMBL::Registry-&gt;get_adaptor('Multi','compara','GeneMember');

# fetch a Member
my $member = $genemember_adaptor-&gt;fetch_by_stable_id('ENSG00000004059');

# print out some information about the Member
print $member-&gt;source_name, ": ", $member-&gt;dnafrag-&gt;name, " ( ", $member-&gt;dnafrag_start, " - ", $member-&gt;dnafrag_end, " ): ", $member-&gt;description, "\n";
</pre>

<p>
The *Member objects have several attributes:
</p>
<ul>
<li><code>stable_id</code> define this member.</li>
<li><code>chr_name</code>, <code>dnafrag_start</code>, <code>dnafrag_end</code>, <code>dnafrag_strand</code> locate this member on the genome but
are only available for ENSEMBLGENE and ENSEMBLPEP.</li>
<li><code>taxon_id</code> corresponds to the NCBI taxonomy identifier (see
<a href="http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/">http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/</a>
for more details).</li>
<li><code>taxon</code> returns a <code>Bio::EnsEMBL::Compara::NCBITaxon</code> object.
From this object you can get additional information about the species.</li>
<li><code>source_name</code> is a string describing where the Member comes from

<dl>
<dt>for GeneMember</dt>
<dd>
  <ul>
  <li>ENSEMBLGENE, derived from an EnsEMBL gene</li>
  <li>EXTERNALGENE, loaded from an external source (currently unused in the live databases)</li>
  </ul>
</dd>
<dt>for SeqMember</dt>
<dd>
  <ul>
  <li>ENSEMBLPEP, derived from an EnsEMBL translation</li>
  <li>ENSEMBLTRANS, derived from an EnsEMBL transcript</li>
  <li>Uniprot/SWISSPROT, derived from a Uniprot/Swissprot entry</li>
  <li>Uniprot/SPTREMBL, derived from a Uniprot/SP-TrEMBL entry</li>
  <li>EXTERNALPEP, loaded from an external source (currently unused in the live databases)</li>
  <li>EXTERNALLTRANS, loaded from an external source (currently unused in the live databases)</li>
  </ul>
</dd>
</dl>

</li></ul>



<pre class="code sh_perl">
my $taxon = $member-&gt;taxon;
print "common_name ", $taxon-&gt;common_name,"\n";
print "genus ", $taxon-&gt;genus,"\n";
print "species ", $taxon-&gt;species,"\n";
print "binomial ", $taxon-&gt;binomial,"\n";
print "classification ", $taxon-&gt;classification,"\n";
</pre>

<p>
In our example the species is human, so the output will look like this:
</p>
<pre>
common_name:    human
genus:          Homo
species:        sapiens
binomial:       Homo sapiens
classification: sapiens Homo Hominidae Catarrhini Haplorrhini Primates Euarchontoglires Eutheria Mammalia Euteleostomi Vertebrata Craniata Chordata Metazoa Eukaryota
</pre>

<h3>GeneTree Objects</h3>
<p>GeneTree objects give us the phylogenetic context for a set of genes, as well as their alignment.</p>
<p>
    In general, you would want to fetch the gene tree for a given gene of interest. The GeneTreeAdaptor has a
    fetching method called <code>fetch_all_by_Member()</code>. You will need the GeneMember object for your
    query gene, therefore you will fetch the GeneMember first like in this example:
</p>

<pre class="code sh_perl">
# first, let's get our GeneMember of interest from a GeneMemberAdaptor
my $genemem_adapt = $registry-&gt;get_adaptor( 'Multi', 'compara', 'GeneMember' );
my $genemem = $genemem_adapt-&gt;fetch_by_stable_id('ENSG00000238344');

# next, set up a GeneTreeAdaptor and fetch the default tree for our GeneMember
my $genetree_adapt = $registry-&gt;get_adaptor( 'Multi', 'compara', 'GeneTree' );
my $genetree = $genetree_adapt-&gt;fetch_default_for_Member($genemem);

# look at all members of the tree
print "Members of tree:\n";
my @members = @{ $genetree-&gt;get_all_Members };
foreach my $m ( @members ) {
    print $m-&gt;name, "\n";
}

# print the full tree in Newick format
print $genetree-&gt;newick_format() . "\n";
</pre>

<p>
GeneTree objects not only hold the structure of the phylogeny, they also hold the gene alignment upon which the tree was based. This can be printed out using the following:
</p>

<pre class="code sh_perl">
    $genetree-&gt;print_alignment_to_file('/path/to/file', -format=&gt;'clustalw');
</pre>

<h3>Homology Objects</h3>

<p>
A Homology object represents either an orthologous or paralogous relationships between two members.
</p>

<p>
Typically you want to get homologies for a given gene. As with the GeneTreeAdaptor, the HomologyAdaptor has a
fetching method called <code>fetch_all_by_Member()</code>. You will need the GeneMember object for your
query gene, therefore you will fetch the GeneMember first like in this example:
</p>

<pre class="code sh_perl">
# first you have to get a GeneMember object. In case of homology is a gene, in
# case of family it can be a gene or a protein

my $gene_member_adaptor = Bio::EnsEMBL::Registry-&gt;get_adaptor('Multi', 'compara', 'GeneMember');
my $gene_member = $gene_member_adaptor-&gt;fetch_by_stable_id('ENSG00000004059');

# then you get the homologies where the member is involved

my $homology_adaptor = Bio::EnsEMBL::Registry-&gt;get_adaptor('Multi', 'compara', 'Homology');
my $homologies = $homology_adaptor-&gt;fetch_all_by_Member($gene_member);

# That will return a reference to an array with all homologies (orthologues in
# other species and paralogues in the same one)
# Then for each homology, you can get all the Members implicated

foreach my $homology (@{$homologies}) {
  # You will find different kind of description
  # see ensembl-compara/docs/docs/schema_doc.html for more details

  print $homology-&gt;description," ", $homology-&gt;taxonomy_level,"\n";

  # And if they are defined dN and dS related values

  print " dn ", $homology-&gt;dn,"\n";
  print " ds ", $homology-&gt;ds,"\n";
  print " dnds_ratio ", $homology-&gt;dnds_ratio,"\n";
}
</pre>

<p>
Each homology relation has exactly 2 members, you should find there the initial member used as a query.
The get_all_Members method returns an array of SeqMember objects. The SeqMember is actually an AlignedMember
(for the underlying protein) and contains information about how this SeqMember has been aligned.
</p>

<pre class="code sh_perl">
my $homology = $homologies-&gt;[0]; # take one of the homologies and look into it

foreach my $member (@{$homology-&gt;get_all_Members}) {

  # each AlignedMember contains both the information on the SeqMember and in
  # relation to the homology

  print (join " ", map { $member-&gt;$_ } qw(stable_id taxon_id))."\n";
  print (join " ", map { $member-&gt;$_ } qw(perc_id perc_pos perc_cov))."\n";

}
</pre>

<p>
You can get the original alignment used to define an homology:
</p>

<pre class="code sh_perl">
    $homology-&gt;print_alignment_to_file('/path/to/file', -format=&gt;'fasta');
</pre>

<h3>Family Objects</h3>

<p>
Families are clusters of proteins including all the EnsEMBL proteins plus all the
metazoan SwissProt and SP-Trembl entries. The object and the adaptor are really
similar to the previous ones.
</p>

<pre class="code sh_perl">
my $gene_member_adaptor = Bio::EnsEMBL::Registry-&gt;get_adaptor('Multi', 'compara', 'GeneMember');
my $gene_member = $gene_member_adaptor-&gt;fetch_by_stable_id('ENSG00000004059');

my $family_adaptor = Bio::EnsEMBL::Registry-&gt;get_adaptor('Multi','compara','Family');
my $families = $family_adaptor-&gt;fetch_all_by_GeneMember($gene_member);

foreach my $family (@{$families}) {
    print join(" ", map { $family-&gt;$_ }  qw(description description_score))."\n";

    foreach my $member (@{$family-&gt;get_all_Members}) {
        print $member-&gt;stable_id," ",$member-&gt;taxon_id,"\n";
    }

    $family-&gt;print_alignment_to_file('/path/to/file', -format=&gt;'phylip');
    $family-&gt;print_alignment_to_file('/path/to/file', -format=&gt;'phylip', -seq_type =&gt; 'cds');
}
</pre>

<h2 id="efficiency">Memory management and code efficiency</h2>
<p>There are a myriad of ways to ensure optimal performance of your code. Here, we provide just a few tricks that pertain specifically to EnsEMBL APIs.</p>
<h4>Fetching from adaptors</h4>
<p>
    In all examples above, we've used a <code>foreach</code> to loop through the results of a <code>fetch_all_by_YY</code> call. This is fine for small datasets. However, adaptors can
    also support a <code>while</code> + <code>shift</code> combo for memory efficiency:
</p>

<pre class="code sh_perl">
my $members = $genetree->get_all_Members;
while ( my $m = shift @$members ) {
    # do something with member
}
</pre>

<h4>Releasing trees from memory</h4>
<p>
    When working with many GeneTree objects, memory can quickly get out of hand. This is because our current object model uses a cyclic graph of Perl references.
    As a consequence, the usual garbage-collector is not able to release the memory used by a gene tree when you lose its reference (unlike most of the Ensembl objects). 
    This means that you will have to call <code>release_tree()</code> on each tree after using it.
</p>

<h4>Preloading data</h4>
<p>
    Most of the objects do lazy-loading of related objects via queries to the database. This system is sub-optimal when there are a lot of objects to
    fetch or if the server is distant. Our <code>Bio::EnsEMBL::Compara::Utils::Preloader</code> module provides several methods to do a bulk-loading of objects in a minimum number of queries.
    This will result in a higher memory usage, but faster processing of data. 
</p>

<br>

<h2 id="help">Further help</h2>

<p>
    A complete reference to the objects and methods used in the Compara database API can be found in the <a href="/info/docs/Doxygen/compara-api/index.html">Compara Perl API Documentation</a>.
</p>
<p>
For additional information or help, mail the <a href="http://lists.ensembl.org/mailman/listinfo/dev" rel="external">ensembl-dev</a> mailing list.
You will need to subscribe to this <a href="/info/about/contact/mailing.html">mailing list</a> to use it.
</p>

<!-- End of real content -->

</body>
</html>
